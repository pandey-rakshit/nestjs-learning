# Modules

- A module is a class annoted with `@Module()` decorator.

- The `@Module()` decorator provides metadata that Nest makes use of to organize the application structure.

- Each application has at least one module, a `root module`.

- The `root module` is the starting point Nest uses to build the application graph - the internal data structure Nest uses to resolve module and provider relationships and dependencies.

```ts
// module.ts

import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
```

- A feature module simply organizes code relevant for a specific feature, keeping code organized and establishing clear boundaries.

```

                                RootModules(ApplicationModule)
                                            ^
                                            |
      |────────────────>────────────────────^─────────────────<──────────────────|
      |                                     |                                    |
      |                                     |                                    |
Module1(AuthModule)             Module2(UserModuel)                     Module3(ChatModule)

```

## Shared modules

- In Nest, modules are singletons by default, and thus you can share the same instance of any provider between multiple modules effortlessly.

- Every module is automatically a shared module. Once created it can be reused by any module.

## Global Module and Dynamic Module

- The `@Global()` decorator makes the module global-scoped. Global modules should be registered only once, generally by the root or core module

- The Nest module system includes a powerful feature called dynamic modules. This feature enables you to easily create customizable modules that can register and configure providers dynamically.
