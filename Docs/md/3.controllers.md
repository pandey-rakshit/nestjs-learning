# Controllers

- Controllers are responsible for handling incoming requests and returning responses to the client.

- A controller's purpose is to receive specific requests for the application

- The routing mechanism controls which controller receives which requests.

```js


                        ├───────── Controllers
          httpRequest   |
Client  ────────────────│───────── Controllers
                        |
                        └───────── Controllers


```

## Routing

- `@Controller()` decorator is required to define a basic controller.

- Using a path prefix in a `@Controller()` decorator allows us to easily group a set of related routes, and minimize repetitive code.

```ts
import { Controller, Get } from '@nestjs/common';

// Here we created a group as this controller will only used for request those have path 'cats' as prefix

@Controller('cats')
export class CatsController {
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}
```

> **Note:** To create a controller using the CLI, simply execute the `nest g controller [name]` command.

### What is the route path?

- The route path for a handler is determined by concatenating the (optional) prefix declared for the controller, and any path specified in the method's decorator

- Here in the code above, The `@Get()` HTTP request method decorator before the `findAll()` method tells Nest to create a handler for a specific endpoint for HTTP requests.

## Request Object

- Handlers often need access to the client request details.

- Nest provides access to the request object of the underlying platform (Express by default)

- We can access the request object by instructing Nest to inject it by adding the `@Req()` decorator to the handler's signature.

- Nest provides decorators for all of the standard HTTP methods: `@Get()`,`@Post()`, `@Put()`, `@Delete()`, `@Patch()`, `@Options()`, and `@Head()`. In addition, `@All()` defines an endpoint that handles all of them.

```ts
import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}
```

Below is a list of the provided decorators and the plain platform-specific objects they represent.

- `@Request()`, `@Req()` - req
- `@Response()`, `@Res()*` - res
- `@Next()` - next
- `@Session()` - req.session
- `@Param(key?: string)` - req.params / req.params[key]
- `@Body(key?: string)` - req.body / req.body[key]
- `@Query(key?: string)` - req.query / req.query[key]
- `@Headers(name?: string)` - req.headers / req.headers[name]
- `@Ip()` - req.ip
- `@HostParam()` - req.hosts

## Route wildcards

- Pattern based routes are supported as well. For instance, the asterisk is used as a wildcard, and will match any combination of characters

```ts

@Get('ab*cd')
findAll() {
  return 'This route uses a wildcard';
}

```

## Request Payload

- Our previous example of the POST route handler didn't accept any client params. Let's fix this by adding the `@Body()` decorator.

```ts
// controller.ts


@Post()
async create(@Body() createCatDto: CreateCatDto) {
  return 'This action adds a new cat';
}

```

- we need to determine the DTO (Data Transfer Object) schema

- A DTO is an object that defines how the data will be sent over the network.

- We could determine the DTO schema by using TypeScript interfaces, or by simple classes.

- TypeScript interfaces are removed during the transpilation, Nest can't refer to them at runtime. This is important because features such as `Pipes` enable additional possibilities when they have access to the metatype of the variable at runtime.

```ts
// DTO (Data Transfer Object)
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}
```
